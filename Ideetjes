To do voor taakverdeling voor individueel plan:
- iemand die de pseudo code van a* algoritme programmeerd?
- iemand die f = g + h functies maakt
- andere algoritmes proberen uit te werken: e.g. simulated annealing
- connections loop: van meest moeilijk naar minst moeilijk --> functie schrijven om die volgorde te bepalen waarin connecties gelegd worden
- Visualisatie van kosten per oplossing maken
- Functie schrijven zodat je een oplossing / output als input kan geven en er een chip en visualisatie uit krijgen

A* pathfinding algorithm functions and objects:
open list (nodes to be explored)
closed list (nodes that have been explored and to which the algorithm will not return to)
f = g + h (cost of a node/coordinate) --> kiest elke keer de node met de laagste som van kosten en heuristiek.
g functie vinden (distance between current node and start node)
h fucntie vinden (heuristiek: estimated distance between current and end node)
backtracking functie om geselecteerde nodes voor de path te krijgen

pseudo code A* pathfinding algorithm: https://medium.com/@nicholas.w.swift/easy-a-star-pathfinding-7e6689c7f7b2
1) Initialize the open and closed list (they contain 0 nodes/coordinates at this point)
2) add the start node to the open list (f value can be put in as 0)
3) loop until endnode/location is reached --> while open list is not empty (no nodes are to be further explored)
  - get the current node (Equal to the node with the lowest f value)
  - remove current node from open list and add to closed list
  - if current node equals the end node: found path! --> backtrack through selected nodes to get the path.
  - generate child nodes: children of the current node equal to the adjoining nodes (nodes directly besides the current node)
  - for each child in the children:
      - if child on the closed list: continue to the beginning of the loop
      - Create the  f, g, and h values for the child and calculate f.
      - if childs' position is in the open list nodes positions: 
          - if child's g value is higher than the open list' node g value: continue to beginning of the loop.
      - if not in open list: add child to open list    

