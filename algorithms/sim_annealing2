import random
import math
import copy
import pandas as pd 
import matplotlib.pyplot as plt

from algorithms import astar_algorithm 

class simulated_annealing:
    """ This class implements the simulated annealing algorithm. 
    Method __init__ initiates the chip. 
    Method update_temperature calculates the new temperature after an iteration. 
    Method accept_solution determines whether to accept or reject a new solution. 
    Method reroute_connection chooses a random connection from current solution and reroutes it using A*.  
    Method is_segment_free checks if a segment is free such that you can make a valid new connection. 
    Method calculate_cost calculates the costs for a solution. 
    Method plot_temp plots the iterations against the temperature. 
    Method plot_costs plots the iterations against the costs. 
    Method run runs the simulated annealing algorithm. """
    
    def __init__(self, chip, temperature, cooling_rate, min_temperature):
        self.chip = chip  # chip on which the algorithm is applied
        self.initial_temp = temperature  # starting temperature 
        self.current_temperature = temperature # current temperature
        self.cooling_rate = cooling_rate  # alpha: factor at which the temperature is lowered every iteration
        self.min_temperature = min_temperature  # termination temperature

        # characteristics of the initial / current solution 
        if not chip.occupied_segments:
            print("Occupied segments is empty")
        else:
          self.current_solution = copy.deepcopy(chip.occupied_segments)
       
        self.best_solution = self.current_solution
        self.current_cost = chip.calculate_cost()
        self.best_cost = self.current_cost

    def update_temperature(self):
        """
        This function implements an exponential cooling scheme.
        """
        self.current_temperature = self.current_temperature * self.cooling_rate

    def accept_solution(self, new_cost):
        """
        Checks whether this new solution is a better solution and is then accepted. 
        If it is a worse solution, then use the acceptation probability to make a decision on whether to accept 
        or reject the new solution. This is based on the current temperature. 

        Returns true if the new solution is accepted. 
        """

        # Calculate cost difference (= diff in energy)
        delta_cost = new_cost - self.current_cost

        # If the new solution is better, always accept 
        if delta_cost < 0:
            return True

        # If the energy is >0 (so worse cost), use accepting probability
        # Higher temperature increases the chance of accepting worse solutions
        acceptance_probability = math.exp(-delta_cost / self.current_temperature)
        return random.random() < acceptance_probability

    def random_layers(self, point, connection, new_solution):
        layers_to_add = random.randint(1, self.chip.z_max - point[2])

        steps_up = []

        for layer in range(1, layers_to_add + 1):
            new_coor = (point[0], point[1], point[2] + layer)
            steps_up.append(new_coor)

        for step in zip(steps_up, steps_up[1:]):
            if step in new_solution:
                return None
            
        connection.start_location = steps_up[-1]

        return steps_up
    
    def reroute_from_start(self, connection, old_path, new_solution):
        for segment in zip(old_path, old_path[1:]):
            if segment in new_solution:
                new_solution.remove(segment)

        return self.random_layers(connection.start_location, connection, new_solution)

    def reroute_from_intersection(self, connection, old_path, new_solution, intersection):
        index_intersect = connection.coor_list.index(intersection)
        
        kept_path = None

        for step_back in [1, 2, 3]:
            new_start = connection.coor_list[index_intersect - step_back]
            steps_up = self.random_layers(new_start, connection, new_solution)
            if steps_up:
                kept_path = old_path[:index_intersect - step_back + 1]
                kept_path.extend(steps_up)
                definite_step_back = step_back
                break

        if not kept_path:
            return None
        
        for segment in zip(old_path[index_intersect - definite_step_back:], old_path[index_intersect - definite_step_back + 1:]):
            if segment in new_solution:
                new_solution.remove(segment)

        return kept_path

    def reroute_connection(self, max_attempts = 5):
        """ Removes a random connection from the current solution and chooses a different path 
        for this conncection using the A* algorithm."""
        
        # Copy the current solution (such that you can adapt it)
        new_solution = self.current_solution.copy()
        
        # choose a random connection from the current solution
        intersection =  random.choice(self.chip.intersection_coors)

        for con in self.chip.connections:
            if intersection in con.coor_list:
                connection = con
                break

        # these are the coordinates that form the connection 
        old_path = connection.coor_list

        pertubation = random.choice(['from start', 'from intersection'])

        if pertubation == 'from start':
            steps_up = self.reroute_from_start(connection, old_path, new_solution)
        else:
            steps_up = self.reroute_from_intersection(connection, old_path, new_solution, intersection)

        if steps_up == None:
            return None

        # use A* algorithm to find a new connection
        astar_alg = astar_algorithm.Astar(self.chip)
        astar_alg.connection = connection
        astar_alg.start_node = astar_algorithm.Node(connection.start_location, None)
        astar_alg.end_node = astar_algorithm.Node(connection.end_location, None)

        connection.coor_list = []
        astar_alg.make_connection()

        connection.start_location = old_path[0]

        if not connection.coor_list:
            return None
        
        new_path = steps_up + connection.coor_list 

        # Add this path to the solution
        for segment in zip(new_path, new_path[1:]):
            new_solution.add(segment)  # is new_solution een set of een lijst? anders append gebruiken

        return new_solution  
            
    def calculate_cost(self, solution):
        self.chip.occupied_segments = solution
        return self.chip.calculate_cost()
    
    def plot_temp(self, df_data):
        plt.plot(df_data["iteration"], df_data["temperature"], label="Temperature", color="blue")
        plt.title("Temperature per iteration")
        plt.xlabel("Iteration")
        plt.ylabel("Temperature")
        plt.grid(True)
        plt.legend()
        plt.show()

    def plot_costs(self, df_data):
        plt.plot(df_data["iteration"], df_data["current_cost"], label="Current costs", color="orange")
        plt.plot(df_data["iteration"], df_data["best_cost"], label="Best costs", color="red")
        plt.title("Costs per iteration")
        plt.xlabel("Iteration")
        plt.ylabel("Cost")
        plt.grid(True)
        plt.legend()
        plt.show()

    def run(self, iterations=1000):
        
        logging_data = []
        
        for iteration in range(iterations):
            if self.current_temperature < self.min_temperature:
                break

            # Introduce the pertubation and calculate its associated cost
            new_solution = self.reroute_connection()

            if new_solution == None:
                continue

            new_cost = self.calculate_cost(new_solution)

            # Decide whether to accept the new solution
            if self.accept_solution(new_cost):
                self.current_solution = new_solution
                self.current_cost = new_cost

                # Update best solution if the new solution is better
                if new_cost < self.best_cost:
                    self.best_solution = new_solution
                    self.best_cost = new_cost

            logging_data.append({
            "iteration": iteration,
            "temperature": self.current_temperature,
            "current_cost": self.current_cost,
            "best_cost": self.best_cost,
            })
            
            # Update the temperature 
            self.update_temperature()

        df_data = pd.DataFrame(logging_data)
        # df_data.to_csv("simulated_annealing_log.csv", index=False)

        self.plot_temp(df_data)
        self.plot_costs(df_data)

        return self.best_solution

